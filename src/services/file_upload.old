"""
File Upload Handler - Document Processing and Context Integration
Created with love by Xeeker & Claude - February 2026

Handles uploading and processing various file types for AI context.
"""

import os
import json
from datetime import datetime
from typing import Dict, List, Tuple
import PyPDF2
import docx
from PIL import Image
import pytesseract


class FileUploadHandler:
    """Handle file uploads and extract content for AI context"""
    
    def __init__(self, upload_dir: str = 'data/uploads'):
        self.upload_dir = upload_dir
        
        # Create upload directory if it doesn't exist
        os.makedirs(upload_dir, exist_ok=True)
        
        # Supported file types
        self.supported_extensions = {
            '.txt': self.read_text,
            '.md': self.read_text,
            '.pdf': self.read_pdf,
            '.docx': self.read_docx,
            '.doc': self.read_docx,
            '.png': self.read_image_ocr,
            '.jpg': self.read_image_ocr,
            '.jpeg': self.read_image_ocr,
            '.py': self.read_text,
            '.js': self.read_text,
            '.json': self.read_text,
            '.html': self.read_text,
            '.css': self.read_text,
            '.cpp': self.read_text,
            '.c': self.read_text,
            '.java': self.read_text
        }
    
    def save_upload(self, file_data, filename: str) -> Tuple[bool, str, str]:
        """
        Save uploaded file with incremental numbering
        
        Returns: (success, filepath, message)
        """
        try:
            # Get base name and extension
            base_name, ext = os.path.splitext(filename)
            
            # Check if file already exists, if so add number
            safe_filename = filename
            counter = 1
            
            while os.path.exists(os.path.join(self.upload_dir, safe_filename)):
                safe_filename = f"{base_name}_{counter}{ext}"
                counter += 1
            
            filepath = os.path.join(self.upload_dir, safe_filename)
            
            # Save file
            with open(filepath, 'wb') as f:
                f.write(file_data)
            
            return True, filepath, f"File saved: {safe_filename}"
            
        except Exception as e:
            return False, "", f"Failed to save file: {str(e)}"
    
    def process_file(self, filepath: str) -> Tuple[bool, Dict]:
        """
        Process file and extract content
        
        Returns: (success, content_dict)
        """
        try:
            # Get file extension
            _, ext = os.path.splitext(filepath)
            ext = ext.lower()
            
            # Check if supported
            if ext not in self.supported_extensions:
                return False, {'error': f'Unsupported file type: {ext}'}
            
            # Extract content using appropriate method
            content = self.supported_extensions[ext](filepath)
            
            # Get file metadata
            stat = os.stat(filepath)
            metadata = {
                'filename': os.path.basename(filepath),
                'size_bytes': stat.st_size,
                'uploaded': datetime.now().isoformat(),
                'type': ext[1:]  # Remove leading dot
            }
            
            return True, {
                'content': content,
                'metadata': metadata
            }
            
        except Exception as e:
            return False, {'error': f'Failed to process file: {str(e)}'}
    
    def read_text(self, filepath: str) -> str:
        """Read plain text file"""
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read()
    
    def read_pdf(self, filepath: str) -> str:
        """Extract text from PDF"""
        try:
            text = []
            with open(filepath, 'rb') as f:
                pdf_reader = PyPDF2.PdfReader(f)
                for page in pdf_reader.pages:
                    text.append(page.extract_text())
            return '\n\n'.join(text)
        except Exception as e:
            return f"[PDF reading error: {str(e)}]"
    
    def read_docx(self, filepath: str) -> str:
        """Extract text from DOCX"""
        try:
            doc = docx.Document(filepath)
            text = []
            for paragraph in doc.paragraphs:
                text.append(paragraph.text)
            return '\n\n'.join(text)
        except Exception as e:
            return f"[DOCX reading error: {str(e)}]"
    
    def read_image_ocr(self, filepath: str) -> str:
        """Extract text from image using OCR"""
        try:
            image = Image.open(filepath)
            text = pytesseract.image_to_string(image)
            return text.strip()
        except Exception as e:
            return f"[Image OCR error: {str(e)}]"
    
    def get_recent_uploads(self, limit: int = 10) -> List[Dict]:
        """Get list of recent uploads"""
        try:
            files = []
            for filename in os.listdir(self.upload_dir):
                filepath = os.path.join(self.upload_dir, filename)
                if os.path.isfile(filepath):
                    stat = os.stat(filepath)
                    files.append({
                        'filename': filename,
                        'size_bytes': stat.st_size,
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            
            # Sort by modified time, most recent first
            files.sort(key=lambda x: x['modified'], reverse=True)
            
            return files[:limit]
            
        except Exception as e:
            print(f"Error getting uploads: {e}")
            return []
    
    def delete_upload(self, filename: str) -> Tuple[bool, str]:
        """Delete an uploaded file"""
        try:
            filepath = os.path.join(self.upload_dir, filename)
            if os.path.exists(filepath):
                os.remove(filepath)
                return True, f"Deleted: {filename}"
            else:
                return False, "File not found"
        except Exception as e:
            return False, f"Failed to delete: {str(e)}"
    
    def format_for_context(self, content_dict: Dict) -> str:
        """Format processed file content for AI context"""
        if 'error' in content_dict:
            return f"[File processing error: {content_dict['error']}]"
        
        metadata = content_dict['metadata']
        content = content_dict['content']
        
        formatted = f"""--- Uploaded Document ---
Filename: {metadata['filename']}
Type: {metadata['type']}
Size: {metadata['size_bytes']} bytes
Uploaded: {metadata['uploaded']}

Content:
{content}
--- End of Document ---
"""
        return formatted
